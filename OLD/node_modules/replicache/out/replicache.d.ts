/** The values that can be represented in JSON */
declare type JSONValue = null | string | boolean | number | Array<JSONValue> | JSONObject;
/**
 * A JSON object. We allow undefined values because in TypeScript there is no
 * way to express optional missing properties vs properties with the value
 * `undefined`.
 */
declare type JSONObject = Partial<{
    [key: string]: JSONValue;
}>;
/** Like [[JSONValue]] but deeply readonly */
declare type ReadonlyJSONValue = null | string | boolean | number | ReadonlyArray<ReadonlyJSONValue> | ReadonlyJSONObject;
/** Like [[JSONObject]] but deeply readonly */
declare type ReadonlyJSONObject = Partial<{
    readonly [key: string]: ReadonlyJSONValue;
}>;

declare type HTTPRequestInfo = {
    httpStatusCode: number;
    errorMessage: string;
};

/**
 * Pusher is the function type used to do the fetch part of a push. The request
 * is a POST request where the body is JSON with the type [[PushRequest]].
 */
declare type Pusher = (request: Request) => Promise<HTTPRequestInfo>;
/**
 * This error is thrown when the pusher fails for any reason.
 */
declare class PushError extends Error {
    name: string;
    causedBy?: Error;
    constructor(causedBy?: Error);
}

declare type PullerResult = {
    response?: PullResponse;
    httpRequestInfo: HTTPRequestInfo;
};
/**
 * Puller is the function type used to do the fetch part of a pull. The request
 * is a POST request where the body is JSON with the type [[PullRequest]].
 */
declare type Puller = (request: Request) => Promise<PullerResult>;
/**
 * The shape of a pull response under normal circumstances.
 */
declare type PullResponseOK = {
    cookie?: ReadonlyJSONValue;
    lastMutationID: number;
    patch: PatchOperation[];
};
/**
 * In certain scenarios the server can signal that it does not know about the
 * client. For example, the server might have deleted the client.
 */
declare type ClientStateNotFoundResponse = {
    error: 'ClientStateNotFound';
};
/**
 * PullResponse defines the shape and type of the response of a pull. This is
 * the JSON you should return from your pull server endpoint.
 */
declare type PullResponse = PullResponseOK | ClientStateNotFoundResponse;
/**
 * This type describes the patch field in a [[PullResponse]] and it is used
 * to describe how to update the Replicache key-value store.
 */
declare type PatchOperation = {
    op: 'put';
    key: string;
    value: JSONValue;
} | {
    op: 'del';
    key: string;
} | {
    op: 'clear';
};
/**
 * This error is thrown when the puller fails for any reason.
 */
declare class PullError extends Error {
    name: string;
    causedBy?: Error;
    constructor(causedBy?: Error);
}

/**
 * The different log levels. This is used to determine how much logging to do.
 * `'error'` > `'info'` > `'debug'`... meaning `'error'` has highest priority
 * and `'debug'` lowest.
 */
declare type LogLevel = 'error' | 'info' | 'debug';
interface LogSink {
    log(level: LogLevel, ...args: unknown[]): void;
    flush?(): Promise<void>;
}
/**
 * An implementation of [[Logger]] that logs using `console.log` etc
 */
declare const consoleLogSink: LogSink;

declare const hashTag: unique symbol;
/**
 * Opaque type representing a hash. The only way to create one is using `parse`
 * or `hashOf` (except for static unsafe cast of course).
 */
declare type Hash = {
    [hashTag]: true;
};

/**
 * Store defines a transactional key/value store that Replicache stores all data
 * within.
 *
 * For correct operation of Replicache, implementations of this interface must
 * provide [strict
 * serializable](https://jepsen.io/consistency/models/strict-serializable)
 * transactions.
 *
 * Informally, read and write transactions must behave like a ReadWrite Lock -
 * multiple read transactions are allowed in parallel, or one write.
 * Additionally writes from a transaction must appear all at one, atomically.
 *
 * @experimental This interface is experimental and might be removed or changed
 * in the future without following semver versioning. Please be cautious.
 */
interface Store {
    read(): Promise<Read>;
    withRead<R>(f: (read: Read) => R | Promise<R>): Promise<R>;
    write(): Promise<Write>;
    withWrite<R>(f: (write: Write) => R | Promise<R>): Promise<R>;
    close(): Promise<void>;
    closed: boolean;
}
/**
 * This interface is used so that we can release the lock when the transaction
 * is done.
 *
 * @experimental This interface is experimental and might be removed or changed
 * in the future without following semver versioning. Please be cautious.
 */
interface Release {
    release(): void;
}
/**
 * @experimental This interface is experimental and might be removed or changed
 * in the future without following semver versioning. Please be cautious.
 */
interface Read extends Release {
    has(key: string): Promise<boolean>;
    get(key: string): Promise<ReadonlyJSONValue | undefined>;
    closed: boolean;
}
/**
 * @experimental
 */
interface Write extends Read {
    put(key: string, value: ReadonlyJSONValue): Promise<void>;
    del(key: string): Promise<void>;
    commit(): Promise<void>;
}

declare const internalValueTag: unique symbol;
declare class InternalValueObject {
    private [internalValueTag];
}
/**
 * Opaque type representing a JSON value that we store inside Replicache. These
 * must never escape.
 *
 * Example usages of these values are:
 * - B+Tree values
 * - Mutation args
 * - Cookies
 */
declare type InternalValue = InternalValueObject | string | number | boolean | null;

declare type ClientID = string;

declare type ReadonlyEntry<V> = readonly [key: string, value: V];
/**
 * Describes the changes that happened to Replicache after a
 * [[WriteTransaction]] was committed.
 *
 * @experimental This type is experimental and may change in the future.
 */
declare type Diff = IndexDiff | NoIndexDiff;
/**
 * @experimental This type is experimental and may change in the future.
 */
declare type IndexDiff = readonly DiffOperation<IndexKey>[];
/**
 * @experimental This type is experimental and may change in the future.
 */
declare type NoIndexDiff = readonly DiffOperation<string>[];
declare type DiffOperationAdd<Key, Value = ReadonlyJSONValue> = {
    readonly op: 'add';
    readonly key: Key;
    readonly newValue: Value;
};
declare type DiffOperationDel<Key, Value = ReadonlyJSONValue> = {
    readonly op: 'del';
    readonly key: Key;
    readonly oldValue: Value;
};
declare type DiffOperationChange<Key, Value = ReadonlyJSONValue> = {
    readonly op: 'change';
    readonly key: Key;
    readonly oldValue: Value;
    readonly newValue: Value;
};
/**
 * The individual parts describing the changes that happened to the Replicache
 * data. There are three different kinds of operations:
 * - `add`: A new entry was added.
 * - `del`: An entry was deleted.
 * - `change`: An entry was changed.
 *
 * @experimental This type is experimental and may change in the future.
 */
declare type DiffOperation<Key> = DiffOperationAdd<Key> | DiffOperationDel<Key> | DiffOperationChange<Key>;

/**
 * When using indexes the key is a tuple of the secondary key and the primary
 * key.
 */
declare type IndexKey = readonly [secondary: string, primary: string];

/**
 * The JSON value used as the body when doing a POST to the [pull
 * endpoint](/server-pull).
 */
declare type PullRequest<Cookie = ReadonlyJSONValue> = {
    profileID: string;
    clientID: string;
    cookie: Cookie;
    lastMutationID: number;
    pullVersion: number;
    schemaVersion: string;
};

/**
 * The JSON value used as the body when doing a POST to the [push
 * endpoint](/server-push).
 */
declare type PushRequest = {
    profileID: string;
    clientID: string;
    mutations: Mutation[];
    pushVersion: number;
    schemaVersion: string;
};
/**
 * Mutation describes a single mutation done on the client.
 */
declare type Mutation = {
    readonly id: number;
    readonly name: string;
    readonly args: InternalValue;
    readonly timestamp: number;
};

/**
 * Options for [[ReadTransaction.scan|scan]]
 */
declare type ScanOptions = ScanIndexOptions | ScanNoIndexOptions;
/**
 * Options for [[ReadTransaction.scan|scan]] when scanning over the entire key
 * space.
 */
declare type ScanNoIndexOptions = {
    /** Only include keys starting with `prefix`. */
    prefix?: string;
    /** Only include up to `limit` results. */
    limit?: number;
    /** When provided the scan starts at this key. */
    start?: {
        key: string;
        /** Whether the `key` is exclusive or inclusive. */
        exclusive?: boolean;
    };
};
/**
 * Options for [[ReadTransaction.scan|scan]] when scanning over an index. When
 * scanning over and index you need to provide the `indexName` and the `start`
 * `key` is now a tuple consisting of secondar and primary key
 */
declare type ScanIndexOptions = {
    /** Only include results starting with the *secondary* keys starting with `prefix`. */
    prefix?: string;
    /** Only include up to `limit` results. */
    limit?: number;
    /** Do a [[ReadTransaction.scan|scan]] over a named index. The `indexName`
     * is the name of an index previously created with [[createIndex]]. */
    indexName: string;
    /** When provided the scan starts at this key. */
    start?: {
        key: ScanOptionIndexedStartKey;
        /** Whether the `key` is exclusive or inclusive. */
        exclusive?: boolean;
    };
};
/**
 * Type narrowing of [[ScanOptions]].
 */
declare function isScanIndexOptions(options: ScanOptions): options is ScanIndexOptions;
/**
 * If the options contains an `indexName` then the key type is a tuple of
 * secondary and primary.
 */
declare type KeyTypeForScanOptions<O extends ScanOptions> = O extends ScanIndexOptions ? IndexKey : string;
/**
 * The key to start scanning at.
 *
 * If you are scanning the primary index (i.e., you did not specify
 * `indexName`), then pass a single string for this field, which is the key in
 * the primary index to scan at.
 *
 * If you are scanning a secondary index (i.e., you specified `indexName`), then
 * use the tuple form. In that case, `secondary` is the secondary key to start
 * scanning at, and `primary` (if any) is the primary key to start scanning at.
 */
declare type ScanOptionIndexedStartKey = readonly [secondary: string, primary?: string] | string;

/**
 * This error is thrown when you try to call methods on a closed transaction.
 */
declare class TransactionClosedError extends Error {
    constructor();
}

declare type IterableUnion<T> = AsyncIterable<T> | Iterable<T>;

declare type ScanKey = string | IndexKey;
interface ScanResult<K extends ScanKey, V extends ReadonlyJSONValue> extends AsyncIterable<V> {
    /** The default AsyncIterable. This is the same as [[values]]. */
    [Symbol.asyncIterator](): AsyncIterableIteratorToArray<V>;
    /** Async iterator over the values of the [[ReadTransaction.scan|scan]] call. */
    values(): AsyncIterableIteratorToArray<V>;
    /**
     * Async iterator over the keys of the [[ReadTransaction.scan|scan]]
     * call. If the [[ReadTransaction.scan|scan]] is over an index the key
     * is a tuple of `[secondaryKey: string, primaryKey]`
     */
    keys(): AsyncIterableIteratorToArray<K>;
    /**
     * Async iterator over the entries of the [[ReadTransaction.scan|scan]]
     * call. An entry is a tuple of key values. If the
     * [[ReadTransaction.scan|scan]] is over an index the key is a tuple of
     * `[secondaryKey: string, primaryKey]`
     */
    entries(): AsyncIterableIteratorToArray<readonly [K, V]>;
    /** Returns all the values as an array. Same as `values().toArray()` */
    toArray(): Promise<V[]>;
}
/**
 * An interface that adds a [[toArray]] method to `AsyncIterableIterator`.
 *
 * Usage:
 *
 * ```ts
 * const keys: string[] = await rep.scan().keys().toArray();
 * ```
 */
interface AsyncIterableIteratorToArray<V> extends AsyncIterableIterator<V> {
    toArray(): Promise<V[]>;
}
/**
 * This is called when doing a [[ReadTransaction.scan|scan]] without an
 * `indexName`.
 *
 * @param fromKey The `fromKey` is computed by `scan` and is the key of the
 * first entry to return in the iterator. It is based on `prefix` and
 * `start.key` of the [[ScanNoIndexOptions]].
 */
declare type GetScanIterator = (fromKey: string) => IterableUnion<ReadonlyEntry<ReadonlyJSONValue>>;
/**
 * When using [[makeScanResult]] this is the type used for the function called when doing a [[ReadTransaction.scan|scan]] with an
 * `indexName`.
 *
 * @param indexName The name of the index we are scanning over.
 * @param fromSecondaryKey The `fromSecondaryKey` is computed by `scan` and is
 * the secondary key of the first entry to return in the iterator. It is based
 * on `prefix` and `start.key` of the [[ScanIndexOptions]].
 * @param fromPrimaryKey The `fromPrimaryKey` is computed by `scan` and is the
 * primary key of the first entry to return in the iterator. It is based on
 * `prefix` and `start.key` of the [[ScanIndexOptions]].
 */
declare type GetIndexScanIterator = (indexName: string, fromSecondaryKey: string, fromPrimaryKey: string | undefined) => IterableUnion<readonly [key: IndexKey, value: ReadonlyJSONValue]>;
/**
 * A helper function that makes it easier to implement [[ReadTransaction.scan]]
 * with a custom backend.
 *
 * If you are implementing a custom backend and have an in memory pending async
 * iterable we provide two helper functions to make it easier to merge these
 * together. [[mergeAsyncIterables]] and [[filterAsyncIterable]].
 *
 * For example:
 *
 * ```ts
 * const scanResult = makeScanResult(
 *   options,
 *   options.indexName
 *     ? () => {
 *         throw Error('not implemented');
 *       }
 *     : fromKey => {
 *         const persisted: AsyncIterable<Entry<ReadonlyJSONValue>> = ...;
 *         const pending: AsyncIterable<Entry<ReadonlyJSONValue | undefined>> = ...;
 *         const iter = await mergeAsyncIterables(persisted, pending);
 *         const filteredIter = await filterAsyncIterable(
 *           iter,
 *           entry => entry[1] !== undefined,
 *         );
 *         return filteredIter;
 *       },
 * );
 * ```
 */
declare function makeScanResult<Options extends ScanOptions, Value>(options: Options, getScanIterator: Options extends ScanIndexOptions ? GetIndexScanIterator : GetScanIterator): ScanResult<KeyTypeForScanOptions<Options>, Value>;

/**
 * Function that gets passed into [[Replicache.experimentalWatch]] and gets
 * called when the data in Replicache changes.
 *
 * @experimental This type is experimental and may change in the future.
 */
declare type WatchNoIndexCallback = (diff: NoIndexDiff) => void;
declare type WatchCallbackForOptions<Options extends WatchOptions> = Options extends WatchIndexOptions ? WatchIndexCallback : WatchNoIndexCallback;
/**
 * Function that gets passed into [[Replicache.experimentalWatch]] when doing a
 * watch on a secondary index map and gets called when the data in Replicache
 * changes.
 *
 * @experimental This type is experimental and may change in the future.
 */
declare type WatchIndexCallback = (diff: IndexDiff) => void;
/**
 * Options for [[Replicache.experimentalWatch]].
 *
 * @experimental This interface is experimental and may change in the future.
 */
declare type WatchOptions = WatchIndexOptions | WatchNoIndexOptions;
/**
 * Options object passed to [[Replicache.experimentalWatch]]. This is for an
 * index watch.
 */
declare type WatchIndexOptions = WatchNoIndexOptions & {
    /**
     * When provided, the `watch` is limited to the changes that apply to the index map.
     */
    indexName: string;
};
/**
 * Options object passed to [[Replicache.experimentalWatch]]. This is for a non
 * index watch.
 */
declare type WatchNoIndexOptions = {
    /**
     * When provided, the `watch` is limited to changes where the `key` starts
     * with `prefix`.
     */
    prefix?: string;
    /**
     * When this is set to `true` (default is `false`), the `watch` callback will
     * be called once asynchronously when watch is called. The arguments in that
     * case is a diff where we consider all the existing values in Replicache as
     * being added.
     */
    initialValuesInFirstDiff?: boolean;
};
/**
 * The options passed to [[Replicache.subscribe]].
 */
interface SubscribeOptions<R extends ReadonlyJSONValue | undefined, E> {
    /**
     * Called when the return value of the body function changes.
     */
    onData: (result: R) => void;
    /**
     * If present, called when an error occurs.
     */
    onError?: (error: E) => void;
    /**
     * If present, called when the subscription is removed/done.
     */
    onDone?: () => void;
}

/**
 * ReadTransactions are used with [[Replicache.query]] and
 * [[Replicache.subscribe]] and allows read operations on the
 * database.
 */
interface ReadTransaction {
    readonly clientID: string;
    /**
     * Get a single value from the database. If the `key` is not present this
     * returns `undefined`.
     *
     * Important: The returned JSON is readonly and should not be modified. This
     * is only enforced statically by TypeScript and there are no runtime checks
     * for performance reasons. If you mutate the return value you will get
     * undefined behavior.
     */
    get(key: string): Promise<ReadonlyJSONValue | undefined>;
    /** Determines if a single `key` is present in the database. */
    has(key: string): Promise<boolean>;
    /** Whether the database is empty. */
    isEmpty(): Promise<boolean>;
    /**
     * Gets many values from the database. This returns a [[ScanResult]] which
     * implements `AsyncIterable`. It also has methods to iterate over the
     * [[ScanResult.keys|keys]] and [[ScanResult.entries|entries]].
     *
     * If `options` has an `indexName`, then this does a scan over an index with
     * that name. A scan over an index uses a tuple for the key consisting of
     * `[secondary: string, primary: string]`.
     *
     * If the [[ScanResult]] is used after the `ReadTransaction` has been closed
     * it will throw a [[TransactionClosedError]].
     *
     * Important: The returned JSON is readonly and should not be modified. This
     * is only enforced statically by TypeScript and there are no runtime checks
     * for performance reasons. If you mutate the return value you will get
     * undefined behavior.
     */
    scan(): ScanResult<string, ReadonlyJSONValue>;
    /**
     * Gets many values from the database. This returns a [[ScanResult]] which
     * implements `AsyncIterable`. It also has methods to iterate over the
     * [[ScanResult.keys|keys]] and [[ScanResult.entries|entries]].
     *
     * If `options` has an `indexName`, then this does a scan over an index with
     * that name. A scan over an index uses a tuple for the key consisting of
     * `[secondary: string, primary: string]`.
     *
     * If the [[ScanResult]] is used after the `ReadTransaction` has been closed
     * it will throw a [[TransactionClosedError]].
     *
     * Important: The returned JSON is readonly and should not be modified. This
     * is only enforced statically by TypeScript and there are no runtime checks
     * for performance reasons. If you mutate the return value you will get
     * undefined behavior.
     */
    scan<Options extends ScanOptions>(options?: Options): ScanResult<KeyTypeForScanOptions<Options>, ReadonlyJSONValue>;
}
/**
 * WriteTransactions are used with *mutators* which are registered using
 * [[ReplicacheOptions.mutators]] and allows read and write operations on the
 * database.
 */
interface WriteTransaction extends ReadTransaction {
    /**
     * Sets a single `value` in the database. The `value` will be encoded using
     * `JSON.stringify`.
     */
    put(key: string, value: JSONValue): Promise<void>;
    /**
     * Removes a `key` and its value from the database. Returns `true` if there was a
     * `key` to remove.
     */
    del(key: string): Promise<boolean>;
    /**
     * Overrides [[ReadTransaction.get]] to return a mutable [[JSONValue]].
     */
    get(key: string): Promise<JSONValue | undefined>;
    /**
     * Overrides [[ReadTransaction.scan]] to return a mutable [[JSONValue]].
     */
    scan(): ScanResult<string, JSONValue>;
    scan<Options extends ScanOptions>(options?: Options): ScanResult<KeyTypeForScanOptions<Options>, JSONValue>;
}
/**
 * The definition of an index. This is used with
 * [[Replicache.createIndex|createIndex]] when creating indexes.
 */
interface CreateIndexDefinition {
    /** The name of the index. This is used when you [[ReadTransaction.scan|scan]] over an index. */
    name: string;
    /**
     * The prefix, if any, to limit the index over. If not provided the values of
     * all keys are indexed.
     */
    prefix?: string;
    /**
     * A [JSON Pointer](https://tools.ietf.org/html/rfc6901) pointing at the sub
     * value inside each value to index over.
     *
     * For example, one might index over users' ages like so:
     * `createIndex({name: 'usersByAge', keyPrefix: '/user/', jsonPointer: '/age'})`
     */
    jsonPointer: string;
    /**
     * If `true`, indexing empty values will not emit a warning.  Defaults to `false`.
     */
    allowEmpty?: boolean;
}

/**
 * The options passed to [[Replicache]].
 */
interface ReplicacheOptions<MD extends MutatorDefs> {
    /**
     * This is the URL to the server endpoint dealing with the push updates. See
     * [Push Endpoint Reference](https://doc.replicache.dev/server-push) for more
     * details.
     *
     * If not provided, push requests will not be made unless a custom
     * [[ReplicacheOptions.pusher]] is provided.
     */
    pushURL?: string;
    /**
     * This is the authorization token used when doing a
     * [pull](https://doc.replicache.dev/server-pull#authorization) and
     * [push](https://doc.replicache.dev/server-push#authorization).
     */
    auth?: string;
    /**
     * This is the URL to the server endpoint dealing with pull. See [Pull
     * Endpoint Reference](https://doc.replicache.dev/server-pull) for more
     * details.
     *
     * If not provided, pull requests will not be made unless a custom
     * [[ReplicacheOptions.puller]] is provided.
     */
    pullURL?: string;
    /**
     * The name of the Replicache database.
     *
     * It is important to use user specific names so that if there are multiple
     * tabs open for different distinct users their data is kept separate.
     *
     * For efficiency and performance, a new [[Replicache]] instance will
     * initialize its state from the persisted state of an existing [[Replicache]]
     * instance with the same `name`, domain and browser profile.
     *
     * Mutations from one [[Replicache]] instance may be pushed using the
     * [[ReplicacheOptions.auth]], [[ReplicacheOptions.pushURL]],
     * [[ReplicacheOptions.pullURL]], [[ReplicacheOptions.pusher]], and
     * [[ReplicacheOptions.puller]]  of another Replicache instance with the same
     * `name`, domain and browser profile.
     *
     * You can use multiple Replicache instances for the same user as long as the
     * names are unique.  e.g. `name: `$userID:$roomID`
     */
    name: string;
    /**
     * The schema version of the data understood by this application. This enables
     * versioning of mutators (in the push direction) and the client view (in the
     * pull direction).
     */
    schemaVersion?: string;
    /**
     * The duration between each [[pull]] in milliseconds. Set this to `null` to
     * prevent pulling in the background.  Defaults to 60 seconds.
     */
    pullInterval?: number | null;
    /**
     * The delay between when a change is made to Replicache and when Replicache
     * attempts to push that change.
     */
    pushDelay?: number;
    /**
     * Determines how much logging to do. When this is set to `'debug'`,
     * Replicache will also log `'info'` and `'error'` messages. When set to
     * `'info'` we log `'info'` and `'error'` but not `'debug'`. When set to
     * `'error'` we only log `'error'` messages.
     * Default is `'info'`.
     */
    logLevel?: LogLevel;
    /**
     * Enables custom handling of logs.
     *
     * By default logs are logged to the console.  If you would like logs to be
     * sent elsewhere (e.g. to a cloud logging service like DataDog) you can
     * provide an array of [[LogSink]]s.  Logs at or above
     * [[ReplicacheOptions.logLevel]] are sent to each of these [[LogSink]]s.
     * If you would still like logs to go to the console, include
     * [[consoleLogSink]] in the array.
     *
     * ```ts
     * logSinks: [consoleLogSink, myCloudLogSink],
     * ```
     */
    logSinks?: LogSink[];
    /**
     * An object used as a map to define the *mutators*. These gets registered at
     * startup of [[Replicache]].
     *
     * *Mutators* are used to make changes to the data.
     *
     * #### Example
     *
     * The registered *mutations* are reflected on the
     * [[Replicache.mutate|mutate]] property of the [[Replicache]] instance.
     *
     * ```ts
     * const rep = new Replicache({
     *   name: 'user-id',
     *   mutators: {
     *     async createTodo(tx: WriteTransaction, args: JSONValue) {
     *       const key = `/todo/${args.id}`;
     *       if (await tx.has(key)) {
     *         throw new Error('Todo already exists');
     *       }
     *       await tx.put(key, args);
     *     },
     *     async deleteTodo(tx: WriteTransaction, id: number) {
     *       ...
     *     },
     *   },
     * });
     * ```
     *
     * This will create the function to later use:
     *
     * ```ts
     * await rep.mutate.createTodo({
     *   id: 1234,
     *   title: 'Make things work offline',
     *   complete: true,
     * });
     * ```
     *
     * #### Replays
     *
     * *Mutators* run once when they are initially invoked, but they might also be
     * *replayed* multiple times during sync. As such *mutators* should not modify
     * application state directly. Also, it is important that the set of
     * registered mutator names only grows over time. If Replicache syncs and
     * needed *mutator* is not registered, it will substitute a no-op mutator, but
     * this might be a poor user experience.
     *
     * #### Server application
     *
     * During push, a description of each mutation is sent to the server's [push
     * endpoint](https://doc.replicache.dev/server-push) where it is applied. Once
     * the *mutation* has been applied successfully, as indicated by the client
     * view's
     * [`lastMutationId`](https://doc.replicache.dev/server-pull#lastmutationid)
     * field, the local version of the *mutation* is removed. See the [design
     * doc](https://doc.replicache.dev/design#commits) for additional details on
     * the sync protocol.
     *
     * #### Transactionality
     *
     * *Mutators* are atomic: all their changes are applied together, or none are.
     * Throwing an exception aborts the transaction. Otherwise, it is committed.
     * As with [[query]] and [[subscribe]] all reads will see a consistent view of
     * the cache while they run.
     */
    mutators?: MD;
    /**
     * Options to use when doing pull and push requests.
     */
    requestOptions?: RequestOptions;
    /**
     * Allows passing in a custom implementation of a [[Puller]] function. This
     * function is called when doing a pull and it is responsible for
     * communicating with the server.
     *
     * Normally, this is just a POST to a URL with a JSON body but you can provide
     * your own function if you need to do things differently.
     */
    puller?: Puller;
    /**
     * Allows passing in a custom implementation of a [[Pusher]] function. This
     * function is called when doing a push and it is responsible for
     * communicating with the server.
     *
     * Normally, this is just a POST to a URL with a JSON body but you can provide
     * your own function if you need to do things differently.
     */
    pusher?: Pusher;
    /**
     * The license key for Replicache. This parameter is required for Replicache to
     * function. See https://replicache.dev for how to acquire a license key.
     *
     * YOU SHOULD PASS TEST_LICENSE_KEY IN AUTOMATED TESTS. It disables license
     * checks for several minutes. If you pass a normal license key in tests, each test
     * that instantiates Replicache will attempt to perform a license check against
     * Replicache's licensing server, potentially increasing your monthly active browser
     * profile count, slowing the test down, and spamming Replicache's servers.
     */
    licenseKey: string;
    /**
     * Allows implementing the underlying storage layer completely in JavaScript.
     *
     * @experimental This option is experimental and might be removed or changed
     * in the future without following semver versioning. Please be cautious.
     */
    experimentalKVStore?: Store;
}

declare type ClientMap = ReadonlyMap<ClientID, Client>;
declare type Client = {
    /**
     * A UNIX timestamp in milliseconds updated by the client once a minute
     * while it is active and every time the client persists its state to
     * the perdag.
     * Should only be updated by the client represented by this structure.
     */
    readonly heartbeatTimestampMs: number;
    /**
     * The hash of the commit in the perdag this client last persisted.
     * Should only be updated by the client represented by this structure.
     */
    readonly headHash: Hash;
    /**
     * The mutationID of the commit at headHash (mutationID if it is a
     * local commit, lastMutationID if it is an index change or snapshot commit).
     * Should only be updated by the client represented by this structure.
     * Read by other clients to determine if there are unacknowledged pending
     * mutations for them to push on behalf of the client represented by this
     * structure.
     * This is redundant with information in the commit graph at headHash,
     * but allows other clients to determine if there are unacknowledged pending
     * mutations without having to load the commit graph at headHash.
     */
    readonly mutationID: number;
    /**
     * The highest lastMutationID received from the server for this client.
     *
     * Should be updated by the client represented by this structure whenever
     * it persists its state to the perdag.
     * Read by other clients to determine if there are unacknowledged pending
     * mutations for them to push on behalf of the client represented by this
     * structure, and *updated* by other clients upon successfully pushing
     * pending mutations to avoid redundant pushes of those mutations.
     *
     * Note: This will be the same as the lastMutationID of the base snapshot of
     * the commit graph at headHash when written by the client represented by this
     * structure.  However, when written by another client pushing pending
     * mutations on this client's behalf it will be different.  This is because
     * the other client does not update the commit graph (it is unsafe to update
     * another client's commit graph).
     */
    readonly lastServerAckdMutationID: number;
};

/**
 * Deletes all IndexedDB data associated with Replicache.
 *
 * Returns an object with the names of the successfully dropped databases
 * and any errors encountered while dropping.
 */
declare function deleteAllReplicacheData(): Promise<{
    dropped: string[];
    errors: unknown[];
}>;

declare type BeginPullResult = {
    requestID: string;
    syncHead: Hash;
    ok: boolean;
};
declare type Poke = {
    baseCookie: ReadonlyJSONValue;
    pullResponse: PullResponse;
};
declare type MaybePromise<T> = T | Promise<T>;
declare type ToPromise<P> = P extends Promise<unknown> ? P : Promise<P>;
/**
 * Returns the name of the IDB database that will be used for a particular Replicache instance.
 * @param name The name of the Replicache instance (i.e., the `name` field of `ReplicacheOptions`).
 * @param schemaVersion The schema version of the database (i.e., the `schemaVersion` field of `ReplicacheOptions`).
 * @returns
 */
declare function makeIDBName(name: string, schemaVersion?: string): string;
declare type MutatorReturn = MaybePromise<JSONValue | void>;
/**
 * The type used to describe the mutator definitions passed into [Replicache](classes/Replicache)
 * constructor as part of the [[ReplicacheOptions]].
 *
 * See [[ReplicacheOptions]] [[ReplicacheOptions.mutators|mutators]] for more
 * info.
 */
declare type MutatorDefs = {
    [key: string]: (tx: WriteTransaction, args?: any) => MutatorReturn;
};
declare type MakeMutator<F extends (tx: WriteTransaction, ...args: [] | [JSONValue]) => MutatorReturn> = F extends (tx: WriteTransaction, ...args: infer Args) => infer Ret ? (...args: Args) => ToPromise<Ret> : never;
declare type MakeMutators<T extends MutatorDefs> = {
    readonly [P in keyof T]: MakeMutator<T[P]>;
};
/**
 * Base options for [[PullOptions]] and [[PushOptions]]
 */
interface RequestOptions {
    /**
     * When there are pending pull or push requests this is the _minimum_ amount
     * of time to wait until we try another pull/push.
     */
    minDelayMs?: number;
    /**
     * When there are pending pull or push requests this is the _maximum_ amount
     * of time to wait until we try another pull/push.
     */
    maxDelayMs?: number;
}
/**
 * The reason [[onClientStateNotFound]] was called.
 */
declare type ClientStateNotFoundReason = {
    type: 'NotFoundOnServer';
} | {
    type: 'NotFoundOnClient';
};
declare type PendingMutation = {
    readonly name: string;
    readonly id: number;
    readonly args: ReadonlyJSONValue;
};
declare class Replicache<MD extends MutatorDefs = {}> {
    /** The URL to use when doing a pull request. */
    pullURL: string;
    /** The URL to use when doing a push request. */
    pushURL: string;
    /** The authorization token used when doing a push request. */
    auth: string;
    /** The name of the Replicache database. */
    readonly name: string;
    private readonly _subscriptions;
    private readonly _mutationRecovery;
    /**
     * This is the name Replicache uses for the IndexedDB database where data is
     * stored.
     */
    get idbName(): string;
    /** The schema version of the data understood by this application. */
    readonly schemaVersion: string;
    private get _idbDatabase();
    private _closed;
    private _online;
    private readonly _ready;
    private readonly _profileIDPromise;
    private readonly _clientIDPromise;
    protected readonly _licenseCheckPromise: Promise<boolean>;
    protected _licenseActivePromise: Promise<boolean>;
    private _testLicenseKeyTimeout;
    private _root;
    private readonly _mutatorRegistry;
    /**
     * The mutators that was registered in the constructor.
     */
    readonly mutate: MakeMutators<MD>;
    private _pushCounter;
    private _pullCounter;
    private _pullConnectionLoop;
    private _pushConnectionLoop;
    /**
     * The duration between each periodic [[pull]]. Setting this to `null`
     * disables periodic pull completely. Pull will still happen if you call
     * [[pull]] manually.
     */
    pullInterval: number | null;
    /**
     * The delay between when a change is made to Replicache and when Replicache
     * attempts to push that change.
     */
    pushDelay: number;
    private readonly _requestOptions;
    /**
     * The function to use to pull data from the server.
     */
    puller: Puller;
    /**
     * The function to use to push data to the server.
     */
    pusher: Pusher;
    private readonly _licenseKey;
    private readonly _memdag;
    private readonly _perdag;
    private readonly _idbDatabases;
    private readonly _lc;
    private readonly _closeAbortController;
    private readonly _persistPullLock;
    private _persistIsScheduled;
    private readonly _enableLicensing;
    /**
     * The options used to control the [[pull]] and push request behavior. This
     * object is live so changes to it will affect the next pull or push call.
     */
    get requestOptions(): Required<RequestOptions>;
    /**
     * `onSync` is called when a sync begins, and again when the sync ends. The parameter `syncing`
     * is set to `true` when `onSync` is called at the beginning of a sync, and `false` when it
     * is called at the end of a sync.
     *
     * This can be used in a React like app by doing something like the following:
     *
     * ```js
     * const [syncing, setSyncing] = useState(false);
     * useEffect(() => {
     *   rep.onSync = setSyncing;
     * }, [rep]);
     * ```
     */
    onSync: ((syncing: boolean) => void) | null;
    /**
     * `onClientStateNotFound` is called when the persistent client has been
     * garbage collected. This can happen if the client has not been used for over
     * a week.
     *
     * It can also happen if the server no longer knows about this client.
     *
     * The default behavior is to reload the page (using `location.reload()`). Set
     * this to `null` or provide your own function to prevent the page from
     * reloading automatically.
     */
    onClientStateNotFound: ((reason: ClientStateNotFoundReason) => void) | null;
    /**
     * This gets called when we get an HTTP unauthorized (401) response from the
     * push or pull endpoint. Set this to a function that will ask your user to
     * reauthenticate.
     */
    getAuth: (() => MaybePromise<string | null | undefined>) | null | undefined;
    constructor(options: ReplicacheOptions<MD>);
    protected _memdagHashFunction(): <V extends ReadonlyJSONValue>(data: V) => Hash;
    private _open;
    private _onVisibilityChange;
    private _checkForClientStateNotFoundAndCallHandler;
    private _licenseCheck;
    private _licenseInvalid;
    private _startLicenseActive;
    /**
     * The browser profile ID for this browser profile. Every instance of Replicache
     * browser-profile-wide shares the same profile ID.
     */
    get profileID(): Promise<string>;
    /**
     * The client ID for this instance of Replicache. Each instance of Replicache
     * gets a unique client ID.
     */
    get clientID(): Promise<string>;
    /**
     * `onOnlineChange` is called when the [[online]] property changes. See
     * [[online]] for more details.
     */
    onOnlineChange: ((online: boolean) => void) | null;
    /**
     * A rough heuristic for whether the client is currently online. Note that
     * there is no way to know for certain whether a client is online - the next
     * request can always fail. This property returns true if the last sync attempt succeeded,
     * and false otherwise.
     */
    get online(): boolean;
    /**
     * Whether the Replicache database has been closed. Once Replicache has been
     * closed it no longer syncs and you can no longer read or write data out of
     * it. After it has been closed it is pretty much useless and should not be
     * used any more.
     */
    get closed(): boolean;
    /**
     * Closes this Replicache instance.
     *
     * When closed all subscriptions end and no more read or writes are allowed.
     */
    close(): Promise<void>;
    private _getRoot;
    private _checkChange;
    /**
     * Creates a persistent secondary index in Replicache which can be used with scan.
     *
     * If the named index already exists with the same definition this returns success
     * immediately. If the named index already exists, but with a different definition
     * an error is thrown.
     */
    createIndex(def: CreateIndexDefinition): Promise<void>;
    /**
     * Drops an index previously created with [[createIndex]].
     */
    dropIndex(name: string): Promise<void>;
    private _indexOp;
    protected _maybeEndPull(syncHead: Hash, requestID: string): Promise<void>;
    private _invokePull;
    private _isPullDisabled;
    private _wrapInOnlineCheck;
    private _wrapInReauthRetries;
    private _isPushDisabled;
    protected _invokePush(): Promise<boolean>;
    /**
     * Push pushes pending changes to the [[pushURL]].
     *
     * You do not usually need to manually call push. If [[pushDelay]] is non-zero
     * (which it is by default) pushes happen automatically shortly after
     * mutations.
     */
    private _push;
    /**
     * Pull pulls changes from the [[pullURL]]. If there are any changes
     * local changes will get replayed on top of the new server state.
     */
    pull(): void;
    /**
     * Applies an update from the server to Replicache.
     * Throws an error if cookie does not match. In that case the server thinks
     * this client has a different cookie than it does; the caller should disconnect
     * from the server and re-register, which transmits the cookie the client actually
     * has.
     *
     * @experimental This method is under development and its semantics will change.
     */
    poke(poke: Poke): Promise<void>;
    protected _beginPull(): Promise<BeginPullResult>;
    private _persist;
    private _fireOnClientStateNotFound;
    private _schedulePersist;
    private _changeSyncCounters;
    /**
     * Subscribe to changes to the underlying data. Every time the underlying data
     * changes `body` is called and if the result of `body` changes compared to
     * last time `onData` is called. The function is also called once the first
     * time the subscription is added.
     *
     * This returns a function that can be used to cancel the subscription.
     *
     * If an error occurs in the `body` the `onError` function is called if
     * present. Otherwise, the error is thrown.
     */
    subscribe<R extends ReadonlyJSONValue | undefined, E>(body: (tx: ReadTransaction) => Promise<R>, options: SubscribeOptions<R, E>): () => void;
    /**
     * Watches Replicache for changes.
     *
     * The `callback` gets called whenever the underlying data changes and the
     * `key` changes matches the
     * [[ExperimentalWatchNoIndexOptions|ExperimentalWatchOptions.prefix]]
     * if present. If a change occurs to the data but the change does not impact
     * the key space the callback is not called. In other words, the callback is
     * never called with an empty diff.
     *
     * This gets called after commit (a mutation or a rebase).
     *
     * @experimental This method is under development and its semantics will
     * change.
     */
    experimentalWatch(callback: WatchNoIndexCallback): () => void;
    experimentalWatch<Options extends WatchOptions>(callback: WatchCallbackForOptions<Options>, options?: Options): () => void;
    /**
     * Query is used for read transactions. It is recommended to use transactions
     * to ensure you get a consistent view across multiple calls to `get`, `has`
     * and `scan`.
     */
    query<R>(body: (tx: ReadTransaction) => Promise<R> | R): Promise<R>;
    private _queryInternal;
    private _register;
    private _registerMutators;
    private _mutate;
    /**
     * In the case we get a ChunkNotFoundError we check if the client got garbage
     * collected and if so change the error to a ClientNotFoundError instead
     */
    private _convertToClientStateNotFoundError;
    protected _recoverMutations(preReadClientMap?: ClientMap): Promise<boolean>;
    /**
     * List of pending mutations.
     *
     * Gives a list of local mutations that have
     * mutationID > syncHead.mutationID that exists on the main branch.
     *
     * @experimental This method is experimental and may change in the future.
     */
    experimentalPendingMutations(): Promise<readonly PendingMutation[]>;
}

// TODO when our license is finalized add a link to it.
declare const TEST_LICENSE_KEY = "This key only good for automated testing";

/**
 * Merges an iterable on to another iterable.
 *
 * The two iterables need to be ordered and the `compare` function is used to
 * compare two different elements.
 *
 * If two elements are equal (`compare` returns `0`) then the element from the
 * second iterable is picked.
 *
 * This utility function is provided because it is useful when using
 * [[makeScanResult]]. It can be used to merge an in memory pending async
 * iterable on to a persistent async iterable for example.
 */
declare function mergeAsyncIterables<A, B>(iterableBase: IterableUnion<A>, iterableOverlay: IterableUnion<B>, compare: (a: A, b: B) => number): AsyncIterable<A | B>;

/**
 * Filters an async iterable.
 *
 * This utility function is provided because it is useful when using
 * [[makeScanResult]]. It can be used to filter out tombstones (delete entries)
 * for example.
 */
declare function filterAsyncIterable<V>(iter: IterableUnion<V>, predicate: (v: V) => boolean): AsyncIterable<V>;

/**
 * The current version of Replicache.
 */
declare const version: string;

export { AsyncIterableIteratorToArray, ClientStateNotFoundReason, ClientStateNotFoundResponse, CreateIndexDefinition, Diff as ExperimentalDiff, DiffOperation as ExperimentalDiffOperation, DiffOperationAdd as ExperimentalDiffOperationAdd, DiffOperationChange as ExperimentalDiffOperationChange, DiffOperationDel as ExperimentalDiffOperationDel, IndexDiff as ExperimentalIndexDiff, Read as ExperimentalKVRead, Store as ExperimentalKVStore, Write as ExperimentalKVWrite, NoIndexDiff as ExperimentalNoIndexDiff, WatchCallbackForOptions as ExperimentalWatchCallbackForOptions, WatchIndexCallback as ExperimentalWatchIndexCallback, WatchIndexOptions as ExperimentalWatchIndexOptions, WatchNoIndexCallback as ExperimentalWatchNoIndexCallback, WatchNoIndexOptions as ExperimentalWatchNoIndexOptions, WatchOptions as ExperimentalWatchOptions, GetIndexScanIterator, GetScanIterator, HTTPRequestInfo, IndexKey, IterableUnion, JSONObject, JSONValue, KeyTypeForScanOptions, LogLevel, LogSink, MaybePromise, MutatorDefs, PatchOperation, PendingMutation, Poke, PullError, PullRequest, PullResponse, PullResponseOK, Puller, PullerResult, PushError, PushRequest, Pusher, ReadTransaction, ReadonlyJSONObject, ReadonlyJSONValue, Replicache, ReplicacheOptions, RequestOptions, ScanIndexOptions, ScanNoIndexOptions, ScanOptionIndexedStartKey, ScanOptions, ScanResult, SubscribeOptions, TEST_LICENSE_KEY, TransactionClosedError, WriteTransaction, consoleLogSink, deleteAllReplicacheData, filterAsyncIterable, isScanIndexOptions, makeIDBName, makeScanResult, mergeAsyncIterables, version };
